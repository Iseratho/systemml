#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

source("./scripts/algorithms/entity-resolution/primitives/evaluation.dml") as eval;
source("./scripts/algorithms/entity-resolution/primitives/postprocessing.dml") as post;
source("./scripts/algorithms/entity-resolution/primitives/preprocessing.dml") as pre;
source("./scripts/algorithms/entity-resolution/primitives/pipeline.dml") as pipe;

threshold = 0.9

acm = read("./data/DBLP-ACM/ACM_tokens.csv");
dblp = read("./data/DBLP-ACM/DBLP2_tokens.csv");

acm_embeddings = read("./data/DBLP-ACM/ACM_embeddings.csv");
dblp_embeddings = read("./data/DBLP-ACM/DBLP2_embeddings.csv");

gt = read("./data/DBLP-ACM/DBLP-ACM_perfectMapping.csv");
print(toString(gt, rows=10, cols=10))

acm_class = as.frame(matrix(0, rows=nrow(acm), cols=1));
dblp_class = as.frame(matrix(1, rows=nrow(dblp), cols=1));

acm = cbind(acm, acm_class);
dblp = cbind(dblp, dblp_class);

n_acm = nrow(acm);
n_dblp = nrow(dblp);

# convert_frame_tokens_to_matrix_bow
[X, Y, M_tokens, MX_ids, MY_ids] = pre::convert_frame_tokens_to_matrix_bow_2(dblp,acm);
X = cbind(X, dblp_embeddings)
Y = cbind(Y, acm_embeddings)

THRES = pipe::binary_entity_resolution_pipeline(X, Y, 1, threshold);

sparse = post::untable(THRES);
#dense = table(sparse[,1], sparse[,2]);
print(toString(sparse, rows=10, cols=10))

X_dec = transformdecode(target=sparse[,1], meta=MX_ids[,1], spec="{recode:[C1]}");
Y_dec = transformdecode(target=sparse[,2], meta=MY_ids[,1], spec="{recode:[C1]}");
output = cbind(cbind(X_dec, Y_dec), as.frame(sparse[,3]));
print(toString(output, rows=10));
write(output, "./data/DBLP-ACM/DBLP-ACM_res.csv", sep=",", sparse=FALSE, format="csv");

print(toString(gt, rows=10))
GT_enc = cbind(
    transformapply(target=gt[,1], meta=MX_ids, spec="{recode:[C1]}"),
    transformapply(target=gt[,2], meta=MY_ids, spec="{recode:[C1]}")
);
print(toString(GT_enc, rows=10))
GT = table(GT_enc[,1], GT_enc[,2], 1);

eval::print_eval_stats((THRES > 0), GT);