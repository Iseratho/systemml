#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

acm = read("./data/DBLP-ACM/ACM.csv");
dblp = read("./data/DBLP-ACM/DBLP2.csv");
res = read("./data/DBLP-ACM/DBLP-ACM_temp.csv");

jspec1="{recode:[C1]}"
[X1, MX1] = transformencode(target=acm[,1], spec=jspec1);
# print(toString(X1, rows=10));
# print(toString(MX1, rows=10));

jspec2="{recode:[C1]}"
[X2, MX2] = transformencode(target=dblp[,1], spec=jspec2);
# print(toString(X2, rows=10));
# print(toString(MX2, rows=10));

m1 = nrow(MX1);
m2 = nrow(MX2);
# print(m1);
# print(m2);

# Hack to get the matrix to same dimension by duplicating data
if (m1 > m2) {
  n_row = m1;
  m_pad = m1 - m2;
  # MX2 = rbind(MX2, as.frame(matrix(0, rows=m_pad, cols=1)));
  MX2 = rbind(MX2, MX2[1:m_pad,])
} else {
  n_row = m2;
  m_pad = m2 - m1;
  # MX1 = rbind(MX1, as.frame(matrix(0, rows=m_pad, cols=1)));
  MX1 = rbind(MX1, MX1[1:m_pad,])
}
# print(nrow(MX1));
# print(nrow(MX2));
MX = cbind(MX1, MX2);
# print(toString(MX, rows=10));

n = nrow(X1) * nrow(X2)
e1_mat = X1 %*% matrix(1, rows=1, cols=nrow(X2));
e1_col = matrix(e1_mat, rows=n, cols=1, byrow=TRUE);
e2_mat = X2 %*% matrix(1, rows=1, cols=nrow(X1));
e2_col = matrix(e2_mat, rows=n, cols=1, byrow=FALSE);
# print(toString(res, rows=10, cols=10));
sim = matrix(res, rows=n, cols=1);
# print(toString(sim, rows=10, cols=10));

comb = cbind(e1_col, e2_col, sim);

# print(toString(comb, rows=10000, cols=3));

# only keep non-zero values
filtered = removeEmpty(target=comb, margin="rows", select=comb[,3]);
# print(toString(A, rows=100, cols=3));

jspec_comb = "{recode:[C1, C2]}";
F_res = transformdecode(target=filtered, spec=jspec_comb, meta=MX);
F_res_with_vals = cbind(F_res, as.frame(filtered[,3]));
print(toString(F_res_with_vals, rows=10, cols=3));